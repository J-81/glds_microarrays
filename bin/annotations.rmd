---
author: "NASA GeneLab Project"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
		      fig.width = 12, 
		      fig.height = 8,
		      error = TRUE # since endpoints include saved data, this is safe as requisite data not being saved will block workflow progression.  This allows a debugger to see the erroring Rmarkdown report.
		      )

# load libraries, could be moved to specific chunks if overloading becomes an issue, but easy to remove load related print outs in this chunk
library(limma)
library(oligo)
library(Biobase)
library(stringr)
keytype<-"PROBEID"

# load required objects from rData files
organism_table <- read.csv(file = file.path(codebase_dir,"organisms.csv"), header = TRUE, stringsAsFactors = FALSE)
load("normalized.RData")
load("raw_data.Rdata")
load("runsheet.RData")# named 'targets'

# set up common variables
count <- dim(targets$t1)[1]
```

# `r targets$glds` Normalized Data QA Summary
#### `r Sys.Date()`
#### Organism: `r targets$organism`
#### Platform: `r targets$platform` Microarray


## Normalized Data Class
```{r normalized-class-listing}
normalized_class <- class(normalized)
print(normalized_class)
```

## Mapping Appropriate Annotation Protocol
``` {r flag-setting, error=FALSE}
flags <- c("expressionset_flag","malist_flag","elist_flag")
flag_state <- data.frame(row.names=flags, criteriaMet=rep(FALSE, times=length(flags)))
flag_state["expressionset_flag",] <- (is(normalized,"ExpressionSet")) # as generated by oligo readcel
flag_state["elist_flag", ] <- (is(normalized,"EList")) # as generated by one channel read.maimages
flag_state["malist_flag", ] <- (is(normalized,"MAList")) # as generated by two channel read.maimages

supported_flags <- sum(flag_state[,"criteriaMet"])

print(flag_state)
```

``` {r check-flags}
if (supported_flags != 1) { 
    stop(sprintf("Error: One and only one flag condition should be met. Flag conditions met: %d,  see flag conditions in this markdown file", supported_flags))
}
```

## Study Sample Factor Grouping
```{r study-sample-factor-grouping, echo=FALSE}
  DT::datatable(targets$t1)
```

## Annotation Database and Key Determination
```{r expressionset--database_and_keys, eval=(flag_state["expressionset_flag",]),  include=(flag_state["expressionset_flag",])}
### Import Probe Data
if (length(targets$probe >= 1)){
  print("Branch: 1")
  options(connectionObserver = NULL)
  database <- sub('\\\\.annotation.tar.gz$', '', basename(targets$probe)) 
  cat("\nLoading local probe annotation database: ",database,"\n")
  if(!require(database, character.only=TRUE)) {
    BiocManager::install(database, ask = FALSE)
  }
  install.packages(targets$probe,repos = NULL, verbose = FALSE, quiet = TRUE)
  library(database, character.only=TRUE)
}else {
  print("Branch: 2")
  package <- raw_data@annotation
  package <- gsub("pd.","",package)
  package <- gsub(".v1","transcriptcluster",package)
  package <- gsub("[.]","",package)
  package <- paste0(package,".db")
  database <- package
  cat("\nSearch for package: ",database)
  if(!require(database, character.only=TRUE)) {
    BiocManager::install(database, ask = FALSE)
  }
  library(database, character.only=TRUE)
}
database <- eval(parse( text = database )) # convert from string denoting the database by character to the actual object

expression_df <- data.frame(Biobase::exprs(normalized))
keys<-rownames(expression_df)
print(keys[10:20])
annotation<-data.frame(ID=keys) #assumes Array ID is primary annotation
```


```{r agilent--database_key_determination,  eval=(any(flag_state[c("elist_flag","malist_flag"),])), include=(any(flag_state[c("elist_flag","malist_flag"),]))}
ann.dbi <- organism_table$annotations[str_replace(tolower(organism_table$species), " ", "_") == targets$organism] # Organism specific gene annotation database
ann.dbi=as.character(ann.dbi)
if(!require(ann.dbi, character.only=TRUE)) {
  BiocManager::install(ann.dbi, ask = FALSE)
  library(ann.dbi, character.only=TRUE)
}
library(ann.dbi, character.only=TRUE)
database <- eval(parse( text = ann.dbi )) # convert from string denoting the database by character to the actual object

### Map Annotations from Primary Keytype
if ( !is.null(normalized$genes$Name) ) {
	annotation<-data.frame(ID=normalized$genes$Name) #assumes Array ID is primary annotation, using column name for malist
} else {
	annotation<-data.frame(ID=normalized$genes$SystematicName) #assumes Array ID is primary annotation, using column name for elist
}
annotation$ID <- gsub("\\.\\d+", "", annotation$ID) #remove any version suffixes from IDs, this causes issues when attempting to use these IDs for annotation mapping
cat("\n Initial feature count: ",length(annotation$ID),"\n")
keys <- annotation$ID
keys <- toupper(keys) # required as keys in database are upper


### Test for appropriate keytype
keytype <- NULL
testout <- NULL
testkeys <- keys[100:200]
print(head(testkeys))
cat("\nTesting keys against available keytypes.\n")
db_columns <- columns(database)
mapping_df <- data.frame(row.names=db_columns, mappedIDs = rep(0, times=length(db_columns)))
for (annkey in rownames(mapping_df)) {
	mapped_for_this_key <-try(mapIds(database, keys = testkeys, keytype = annkey, column = "ENTREZID",multiVals = "first")) # try is used here since mapping to nothing results in an error
	mapping_df[annkey, ] = length(mapped_for_this_key)
}
print(mapping_df)
valid_keys <- rownames(which(mapping_df == max(mapping_df), arr.ind=T))

if (length(valid_keys) == 1){
	keytype = valid_keys
} else if ( (length(valid_keys) > 1) && ("ACCNUM" %in% valid_keys) ) {
	keytype = "ACCNUM" # this was observed to be a possible case when both ACCNUM (from genbank) and REFSEQ (forked from genbank) exist in the database
} else {
	print(valid_keys)
	stop("Unsure how to proceed with this kind of mapping")
}

annotation<-data.frame(ID=keys) #assumes Array ID is primary annotation
print(keytype)
```

```{r elist--annotation_and_expression_df_setup, eval=(flag_state["elist_flag",]),  include=(flag_state["elist_flag",])}
expression_df <- cbind(normalized$genes$ProbeUID,normalized$E)
```

```{r malist--annotation_and_expression_df_setup, eval=(flag_state["malist_flag",]),  include=(flag_state["malist_flag",])}
expression_df <- cbind(annotation$ID, normalized$M)
```

## Add annotations
```{r general--add_annotations, eval=TRUE,  include=TRUE}

annkeys = c("REFSEQ","ENSEMBL","SYMBOL","GENENAME","ENTREZID","TAIR","GOSLIM_IDS")
# also fetches STRING_ID through a separate call

if ( exists("database") ) {
	### Map assay database annotations
	## Columns and rows that do not map will be assigned NA
	for ( annkey in annkeys ) {
		skip_to_next <- FALSE
		print(sprintf("Attempting to fetch %s", annkey))
		annotation[annkey] <-tryCatch(
						{
							as.character(mapIds(database,keys = keys,keytype = keytype, column = annkey,multiVals = "first"))
						},
						error=function(cond)
							{
								message(sprintf("Could not map %s", annkey))
								#message(cond)
								skip_to_next <<- TRUE 
								return(NA)
							}
		)
	       if (skip_to_next) { next } # needed as an error will normally prevent next loop
	}


	### Map STRING annotations
	string_db <- STRINGdb::STRINGdb$new( version="11", species=organism_table$taxon[str_replace(tolower(organism_table$species), " ", "_") == targets$organism] ,score_threshold=0)
	string_map<-string_db$map(annotation,"ENTREZID",removeUnmappedRows = TRUE, takeFirst = TRUE)
	string_cols <-string_map[,c("ENTREZID","STRING_id")]
	string_cols <- string_cols[!duplicated(string_cols$ENTREZID),]
	annotation <- dplyr::left_join(annotation,string_cols,by="ENTREZID")
	# rename STRING_id
	annotation <- annotation %>% dplyr::rename(STRING_ID = STRING_id)
} else {
	for ( annkey in annkeys ) {
		annotation[annkey] <- NA
	}
	database <- "NONE_FOUND"
	database$packageName <- "NONE_FOUND"
	keytype <- "COULD_NOT_DETERMINE"
}
```


## Set up for file export
```{r expressionset--format-normalized-annotated, eval=(flag_state["expressionset_flag",]),  include=(flag_state["expressionset_flag",])}
### specific formatting
fData(normalized)<-annotation # assign featureData (an attribute of expressionSet objects
```

```{r agilent--format-normalized-annotated,  eval=(any(flag_state[c("elist_flag","malist_flag"),])), include=(any(flag_state[c("elist_flag","malist_flag"),]))}
### Filter out Control Probes
cat("\n normalized columns",colnames(normalized$genes))
filter <- which(!(annotation$ID %in% c("DARKCORNER","GE_BRIGHTCORNER","NEGATIVECONTROL")))
normalized <- normalized[filter,]
annotation <- annotation[filter,]
expression_df <- expression_df[filter,]
cat("\n Features after control probes removed: ",dim(normalized$genes),"\n")

### Specific export
normalized$annotation <- annotation
```

## Export files
```{r export }
### Generate normalized annotated expression text file
cat("\nGenerating normalized-annotated.txt file\n")
expression_df <- cbind(annotation,expression_df)
write.table(expression_df,"normalized-annotated.txt",quote=FALSE, append = FALSE, row.names = FALSE, sep = "\t")
DT::datatable(head(expression_df, n=30))

cat(sprintf("# Annotated with: %s. Using %s as the match key\n", database$packageName, keytype), file="probe_annotations.txt")
write.table(annotation,"probe_annotations.txt",quote=FALSE, append = TRUE, row.names = FALSE, sep = "\t")
DT::datatable(head(annotation, n=30))

### Annotate the expression set object and save as a file
cat("\nGenerating normalized-annotated.rda file\n")
save(normalized, file = "normalized-annotated.rda")
```
